First:
first of METHOD_BODY : int float if while id 
first of STATEMENT_LIST  : int float if while id 
first of STATEMENT_LIST : int float if while id 
first of STATEMENT STATEMENT_LIST'  : int float if while id 
first of STATEMENT_LIST' : int float if while id \L 
first of STATEMENT STATEMENT_LIST'  : int float if while id 
first of \L  : \L 
first of STATEMENT : int float if while id 
first of DECLARATION  : int float 
first of IF  : if 
first of WHILE  : while 
first of ASSIGNMENT  : id 
first of DECLARATION : int float 
first of PRIMITIVE_TYPE id ;  : int float 
first of PRIMITIVE_TYPE : int float 
first of int  : int 
first of float  : float 
first of IF : if 
first of if ( EXPRESSION ) { STATEMENT } else { STATEMENT }  : if 
first of WHILE : while 
first of while ( EXPRESSION ) { STATEMENT }  : while 
first of ASSIGNMENT : id 
first of id assign EXPRESSION ;  : id 
first of EXPRESSION : id num ( + - 
first of SIMPLE_EXPRESSION EXPRESSION1  : id num ( + - 
first of SIMPLE_EXPRESSION : id num ( + - 
first of TERM SIMPLE_EXPRESSION'  : id num ( 
first of SIGN TERM SIMPLE_EXPRESSION'  : + - 
first of SIMPLE_EXPRESSION' : addop \L 
first of addop TERM SIMPLE_EXPRESSION'  : addop 
first of \L  : \L 
first of TERM : id num ( 
first of FACTOR TERM'  : id num ( 
first of TERM' : mulop \L 
first of mulop FACTOR TERM'  : mulop 
first of \L  : \L 
first of FACTOR : id num ( 
first of id  : id 
first of num  : num 
first of ( EXPRESSION )  : ( 
first of SIGN : + - 
first of +  : + 
first of -  : - 
first of EXPRESSION1 : \L relop 
first of \L  : \L 
first of relop SIMPLE_EXPRESSION  : relop 

Follow:
follow of METHOD_BODY : $ 
follow of STATEMENT_LIST : $ 
follow of STATEMENT_LIST' : $ 
follow of STATEMENT : int float if while id $ } 
follow of DECLARATION : int float if while id $ } 
follow of PRIMITIVE_TYPE : id 
follow of IF : int float if while id $ } 
follow of WHILE : int float if while id $ } 
follow of ASSIGNMENT : int float if while id $ } 
follow of EXPRESSION : ) ; 
follow of SIMPLE_EXPRESSION : relop ) ; 
follow of SIMPLE_EXPRESSION' : relop ) ; 
follow of TERM : addop relop ) ; 
follow of TERM' : addop relop ) ; 
follow of FACTOR : mulop addop relop ) ; 
follow of SIGN : id num ( 
follow of EXPRESSION1 : ) ; 

Parsing table:
non-terminal: ASSIGNMENT
 on $ gives the production: synch 
 on float gives the production: synch 
 on id gives the production: id assign EXPRESSION ; {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)} 
 on if gives the production: synch 
 on int gives the production: synch 
 on while gives the production: synch 
 on } gives the production: synch 
non-terminal: DECLARATION
 on $ gives the production: synch 
 on float gives the production: PRIMITIVE_TYPE id ; {AUX[1].type = AUX[2].type # pop(3)} 
 on id gives the production: synch 
 on if gives the production: synch 
 on int gives the production: PRIMITIVE_TYPE id ; {AUX[1].type = AUX[2].type # pop(3)} 
 on while gives the production: synch 
 on } gives the production: synch 
non-terminal: EXPRESSION
 on ( gives the production: SIMPLE_EXPRESSION EXPRESSION1 {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)} 
 on ) gives the production: synch 
 on + gives the production: SIMPLE_EXPRESSION EXPRESSION1 {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)} 
 on - gives the production: SIMPLE_EXPRESSION EXPRESSION1 {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)} 
 on ; gives the production: synch 
 on id gives the production: SIMPLE_EXPRESSION EXPRESSION1 {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)} 
 on num gives the production: SIMPLE_EXPRESSION EXPRESSION1 {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)} 
non-terminal: EXPRESSION1
 on ) gives the production: \L {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none} 
 on ; gives the production: \L {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none} 
 on relop gives the production: relop SIMPLE_EXPRESSION {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)} 
non-terminal: FACTOR
 on ( gives the production: ( EXPRESSION ) {AUX[3].type = AUX[1].type # AUX[3].op = AUX[1].op # AUX[3].code = AUX[1].code # pop(3)} 
 on ) gives the production: synch 
 on ; gives the production: synch 
 on addop gives the production: synch 
 on id gives the production: id {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)} 
 on mulop gives the production: synch 
 on num gives the production: num {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)} 
 on relop gives the production: synch 
non-terminal: IF
 on $ gives the production: synch 
 on float gives the production: synch 
 on id gives the production: synch 
 on if gives the production: if ( EXPRESSION ) {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ } { STATEMENT } {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 } else { STATEMENT } {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)} 
 on int gives the production: synch 
 on while gives the production: synch 
 on } gives the production: synch 
non-terminal: METHOD_BODY
 on $ gives the production: synch 
 on float gives the production: STATEMENT_LIST {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)} 
 on id gives the production: STATEMENT_LIST {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)} 
 on if gives the production: STATEMENT_LIST {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)} 
 on int gives the production: STATEMENT_LIST {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)} 
 on while gives the production: STATEMENT_LIST {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)} 
non-terminal: PRIMITIVE_TYPE
 on float gives the production: float {AUX[1].type = float # pop(1)} 
 on id gives the production: synch 
 on int gives the production: int {AUX[1].type = int # pop(1)} 
non-terminal: SIGN
 on ( gives the production: synch 
 on + gives the production: 
 on - gives the production: 
 on id gives the production: synch 
 on num gives the production: synch 
non-terminal: SIMPLE_EXPRESSION
 on ( gives the production: TERM {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code} SIMPLE_EXPRESSION' {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)} 
 on ) gives the production: synch 
 on + gives the production: SIGN TERM {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code} SIMPLE_EXPRESSION' {AUX[3].type = AUX[0].type # AUX[3].op = mul # AUX[3].code = AUX[0].code + if (AUX[2].type = minus) newline , Address $ 0 : iconst-1 ; , newline , Address $ 1 : imul ; # Address++ # pop(3)} 
 on - gives the production: SIGN TERM {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code} SIMPLE_EXPRESSION' {AUX[3].type = AUX[0].type # AUX[3].op = mul # AUX[3].code = AUX[0].code + if (AUX[2].type = minus) newline , Address $ 0 : iconst-1 ; , newline , Address $ 1 : imul ; # Address++ # pop(3)} 
 on ; gives the production: synch 
 on id gives the production: TERM {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code} SIMPLE_EXPRESSION' {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)} 
 on num gives the production: TERM {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code} SIMPLE_EXPRESSION' {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)} 
 on relop gives the production: synch 
non-terminal: SIMPLE_EXPRESSION'
 on ) gives the production: \L {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode} 
 on ; gives the production: \L {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode} 
 on addop gives the production: addop TERM {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; } SIMPLE_EXPRESSION' {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)} 
 on relop gives the production: \L {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode} 
non-terminal: STATEMENT
 on $ gives the production: synch 
 on float gives the production: DECLARATION {AUX[1].code = none # pop(1)} 
 on id gives the production: ASSIGNMENT {AUX[1].code = AUX[0].code # pop(1)} 
 on if gives the production: IF {AUX[1].code = AUX[0].code # pop(1)} 
 on int gives the production: DECLARATION {AUX[1].code = none # pop(1)} 
 on while gives the production: WHILE {AUX[1].code = AUX[0].code # pop(1)} 
 on } gives the production: synch 
non-terminal: STATEMENT_LIST
 on $ gives the production: synch 
 on float gives the production: STATEMENT {S[0].incode = AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on id gives the production: STATEMENT {S[0].incode = AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on if gives the production: STATEMENT {S[0].incode = AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on int gives the production: STATEMENT {S[0].incode = AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on while gives the production: STATEMENT {S[0].incode = AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
non-terminal: STATEMENT_LIST'
 on $ gives the production: \L {AUX[0].code = AUX[0].incode} 
 on float gives the production: STATEMENT {S[0].incode = AUX[1].incode + newline + AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on id gives the production: STATEMENT {S[0].incode = AUX[1].incode + newline + AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on if gives the production: STATEMENT {S[0].incode = AUX[1].incode + newline + AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on int gives the production: STATEMENT {S[0].incode = AUX[1].incode + newline + AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
 on while gives the production: STATEMENT {S[0].incode = AUX[1].incode + newline + AUX[0].code} STATEMENT_LIST' {AUX[2].code = AUX[0].code # pop(2)} 
non-terminal: TERM
 on ( gives the production: FACTOR {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code} TERM' {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)} 
 on ) gives the production: synch 
 on ; gives the production: synch 
 on addop gives the production: synch 
 on id gives the production: FACTOR {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code} TERM' {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)} 
 on num gives the production: FACTOR {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code} TERM' {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)} 
 on relop gives the production: synch 
non-terminal: TERM'
 on ) gives the production: \L {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype} 
 on ; gives the production: \L {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype} 
 on addop gives the production: \L {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype} 
 on mulop gives the production: mulop FACTOR {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; } TERM' {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)} 
 on relop gives the production: \L {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype} 
non-terminal: WHILE
 on $ gives the production: synch 
 on float gives the production: synch 
 on id gives the production: synch 
 on if gives the production: synch 
 on int gives the production: synch 
 on while gives the production: while {tempadd} ( EXPRESSION ) {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ } { STATEMENT } {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)} 
 on } gives the production: synch 

METHOD_BODY  
METHOD_BODY----->STATEMENT_LIST  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST----->STATEMENT  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  
STATEMENT  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->DECLARATION  {AUX[1].code = none # pop(1)}  
DECLARATION  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
DECLARATION----->PRIMITIVE_TYPE  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  
PRIMITIVE_TYPE  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
PRIMITIVE_TYPE----->int  {AUX[1].type = int # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST'----->STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
ASSIGNMENT----->id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->\L  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST'----->STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->WHILE  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  WHILE  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
WHILE----->while  {tempadd}  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->relop  SIMPLE_EXPRESSION  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  SIMPLE_EXPRESSION  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  SIMPLE_EXPRESSION  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
ASSIGNMENT----->id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->addop  TERM  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  TERM  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  TERM  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->\L  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST'----->STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->DECLARATION  {AUX[1].code = none # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  DECLARATION  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
DECLARATION----->PRIMITIVE_TYPE  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  PRIMITIVE_TYPE  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
PRIMITIVE_TYPE----->int  {AUX[1].type = int # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST'----->STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
ASSIGNMENT----->id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->\L  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST'----->STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->IF  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  IF  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
IF----->if  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  EXPRESSION  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->relop  SIMPLE_EXPRESSION  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  SIMPLE_EXPRESSION  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  SIMPLE_EXPRESSION  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  STATEMENT  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
ASSIGNMENT----->id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->mulop  FACTOR  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  TERM'  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  FACTOR  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  TERM'  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  FACTOR  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  TERM'  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  TERM'  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  TERM'  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->\L  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  STATEMENT  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT----->ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  ASSIGNMENT  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
ASSIGNMENT----->id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  EXPRESSION  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION----->SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  SIMPLE_EXPRESSION  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION----->TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  TERM  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  SIMPLE_EXPRESSION'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->addop  TERM  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  TERM  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  TERM  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM----->FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  FACTOR  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
FACTOR----->num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  TERM'  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
TERM'----->\L  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  SIMPLE_EXPRESSION'  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
SIMPLE_EXPRESSION'----->\L  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  EXPRESSION1  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
EXPRESSION1----->\L  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
terminals match
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  STATEMENT_LIST'  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
STATEMENT_LIST'----->\L  {AUX[0].code = AUX[0].incode}  
int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[0].code}  id  assign  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  while  {tempadd}  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # saveadd1 # pop(7)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  int  {AUX[1].type = int # pop(1)}  id  ;  {AUX[1].type = AUX[2].type # pop(3)}  {AUX[1].code = none # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  if  (  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  relop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].op = AUX[1].value # AUX[2].type = boolean # AUX[2].code = AUX[0].code + newline + if(AUX[0].type = int) Address $ 0 : icmpl; + if(AUX[0].type = float) Address $ 0 : fcmpl; # Address++ # pop(2)}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  )  {AUX[4].code = AUX[1].code + newline + Address % 0  + if_ + AUX[1].op + label + newline # Address++ }  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  mulop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = mul & AUX[0].type = int) Address $ 0 : imul ; + if(AUX[1].value = mul & AUX[0].type = float) Address $ 0 : fmul ; + if(AUX[1].value = div & AUX[0].type = int) Address $ 0 : idiv ; + if(AUX[1].value = div & AUX[0].type = float) Address $ 0 : fdiv ; }  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[3].type = AUX[1].type # AUX[3].op = AUX[2].value # AUX[3].code = AUX[0].code # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[7].code = AUX[7].code + AUX[1].code + newline + Address % 0  + goto + label + newline # Address++ # Address++ # Address++ # tempadd2 }  else  {  id  assign  id  {AUX[1].type = AUX[0].type # AUX[1].op = none # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iload AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fload AUX[0].value ; # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[0].type # S[0].inop = AUX[0].op # S[0].incode = AUX[0].code}  addop  num  {AUX[1].type = AUX[0].type # AUX[1].code = if(AUX[0].type = int) Address $ 0 : iconst AUX[0].value ; + if(AUX[0].type = float) Address $ 0 : fconst AUX[0].value ; # AUX[1].op = none # Address++ # pop(1)}  {S[0].inop = AUX[0].op # S[0].intype = AUX[0].type # S[0].incode = AUX[0].code}  {AUX[0].code = AUX[0].incode # AUX[0].op = AUX[0].inop # AUX[0].type = AUX[0].intype}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {S[0].intype = AUX[2].intype # S[0].inop = AUX[2].inop # S[0].incode = AUX[2].incode + newline + AUX[0].code + newline + if(AUX[1].value = add & AUX[0].type = int) Address $ 0 : iadd ; + if(AUX[1].value = add & AUX[0].type = float) Address $ 0 : fadd ; + if(AUX[1].value = sub & AUX[0].type = int) Address $ 0 : isub ; + if(AUX[1].value = sub & AUX[0].type = float) Address $ 0 : fsub ; }  {AUX[0].type = AUX[0].intype # AUX[0].op = AUX[0].inop # AUX[0].code = AUX[0].incode}  {AUX[3].code = AUX[0].code # AUX[3].op = AUX[2].value # AUX[3].type = AUX[1].type # Address++ # pop(3)}  {AUX[2].type = AUX[0].type # AUX[2].op = AUX[0].op # AUX[2].code = AUX[0].code # pop(2)}  {AUX[0].type = none # AUX[0].op = none # AUX[0].code = none}  {if(AUX[0].op = none) AUX[2].op = AUX[1].op , AUX[2].type = AUX[1].type # if(AUX[0].op != none) AUX[2].op = AUX[0].op , AUX[2].type = boolean # AUX[2].code = AUX[1].code + newline + AUX[0].code # pop(2)}  ;  {AUX[4].code = AUX[1].code + newline + if(AUX[3].type = int) Address $ 0 : istore_AUX[3].value ; + if(AUX[3].type = float) Address $ 0 : fstore_AUX[3].value ; # Address++ # pop(4)}  {AUX[1].code = AUX[0].code # pop(1)}  }  {AUX[11].code = AUX[11].code + AUX[1].code + newline # saveadd2 # pop(11)}  {AUX[1].code = AUX[0].code # pop(1)}  {S[0].incode = AUX[1].incode + newline + AUX[0].code}  {AUX[0].code = AUX[0].incode}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[2].code = AUX[0].code # pop(2)}  {AUX[1].code = AUX[0].code # print(AUX[1].code); # pop(1)}  
input matches the grammar
